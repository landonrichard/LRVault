# Enumeration & Exploitation in Python
#NCL
---
## Using a Disassembler to Exploit a Compiled Binary
#KaliTools

To try and find vulnerabilities in a compiled binary you need to remember that they consist of machine code instructions which can be represented as an assembly language.
One way to do this is by using a tool call **GDB**. 
>Run `gdb filename`
>Next you can disassemble the main function with `disassemble main`
>You should get this
>![Binary Disassemble Main Example](binary1.png)
>If you look here you can see that there is a buffer of 30 bytes
>![Binary Buffer Example](binary2.png)
>This is important to remember when you run the binary because you can overflow that buffer.

Let's now go run the binary file and have a look at it
>When you run the program its going to ask for a TID
>![Binary Run Example](binary3.png)
>The Question provided the TID as an identifier of 7074
>Let's enter that by `./RE1_64bit 7074`
>![Binary Asks for password](binary4.png)
>We now get asked for a password
>**Remember that the password has a buffer set at 30 bytes**
>If we enter a password smaller than that we get this
>![Binary Incorrect Password Example](binary5.png)
>Now if we run it again and enter a password larger than 30 bytes we should bypass it
>![Binary Success Example](binary6.png)


**Further Reading and Tools**
- [Machine Code](https://en.wikipedia.org/wiki/Machine_code)
- [Assembly language](https://en.wikipedia.org/wiki/Assembly_language)
- [GDB](https://www.gnu.org/software/gdb/)
- [GDB Documentation](https://sourceware.org/gdb/current/onlinedocs/gdb/)
- [Ghidra](https://ghidra-sre.org/)

---
## Using a Disassembler to Exploit a Compiled Binary Cont.
#KaliTools 

To try and find vulnerabilities in a compiled binary you need to remember that they consist of machine code instructions which can be represented as an assembly language.
One way to do this is by using a tool call **GDB**.

First we can try and see what happens if we try and run the binary file.
>We can do this running the command `./RE2_64bit`
>![Attempting to run the binary file](binary7.png)
>The program asks for a TID. The question provided the TID in the form of a identifier of **4930**.
>Lets rerun the program with the TID and see what happens with `./RE2_64bit 4930`
>It worked and now wants a password, which we do not know.
>If you attempt to just use a large password to break the cache you get an error.
>![Binary attempting a password](binary8.png)

We can try to gather more information about this file by using GDB.
>First run GDB on the file with the command `gbd RE2_64bit`
>Now we can check all the functions in the code by using the command `info functions`
>![Using GBD to list all the functions](binary9.png)
>Now we can pry around and look for any functions that seem interesting.
>There is a function named "getflagbytid"
>![Binary GetFlagByTID function](binary10.png)


We can manually call this function and see what happens.
>To do this we can break at line 1 of the main function when the program runs.
>Use the command `break main` and then `r` to run.
>![Binary breaking on main function line 1](binary11.png)
>Now we can try and call the **getflagbytid** function.
>Use the command `call getflagbytid(4930)`. (Remember to add the TID)
>![Return type error](binary12.png)
>We can see that we get an error because we didn't specify what return type.
>We can fix that with the command `call (char *) getflagbytid(4930)`
>![Binary Success](binary13.png)


**Further Reading and Tools**
- [Machine Code](https://en.wikipedia.org/wiki/Machine_code)
- [Assembly language](https://en.wikipedia.org/wiki/Assembly_language)
- [GDB](https://www.gnu.org/software/gdb/)
- [GDB Documentation](https://sourceware.org/gdb/current/onlinedocs/gdb/)
- [Ghidra](https://ghidra-sre.org/)
